// Generated by CoffeeScript 1.6.3
(function() {
  var addCommitLog, fs, getPackageJsonCommits, git, logCommit, main, path, readRepo, remoteGitHost, remoteRepoGroup, root, updatePackageJson;

  fs = require('fs');

  path = require('path');

  git = require('git-node');

  root = '../voxpopuli';

  remoteGitHost = 'github.com';

  remoteRepoGroup = 'deathcap';

  main = function() {
    var commitLogs, cutCommit, cutCommits, file, linkedPaths, newestCommits, node_modules, numProjects, p1, p2, p3, projectName, rawPackageJson, stats, _i, _j, _len, _len1, _ref, _results;
    rawPackageJson = fs.readFileSync(path.join(root, 'package.json'));
    cutCommits = getPackageJsonCommits(rawPackageJson);
    node_modules = path.join(root, 'node_modules');
    linkedPaths = [];
    _ref = fs.readdirSync(node_modules);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      p1 = path.join(node_modules, file);
      stats = fs.lstatSync(p1);
      if (!stats.isSymbolicLink()) {
        continue;
      }
      p2 = fs.readlinkSync(p1);
      p3 = fs.readlinkSync(p2);
      linkedPaths.push(p3);
    }
    numProjects = linkedPaths.length;
    console.log('numProjects', numProjects);
    console.log('linkedPaths', linkedPaths);
    commitLogs = {};
    newestCommits = {};
    _results = [];
    for (_j = 0, _len1 = linkedPaths.length; _j < _len1; _j++) {
      file = linkedPaths[_j];
      projectName = path.basename(file);
      cutCommit = cutCommits[projectName];
      if (cutCommit == null) {
        throw "node module " + projectName + " linked but not found in package.json!";
      }
      _results.push(readRepo(commitLogs, newestCommits, cutCommit, projectName, file, numProjects, function(commitLogs) {
        var msg;
        console.log("=======");
        console.log(commitLogs);
        console.log("=======");
        console.log(newestCommits);
        updatePackageJson(cutCommits, rawPackageJson.toString(), commitLogs, newestCommits);
        msg = addCommitLog(commitLogs);
        return console.log("log=", msg);
      }));
    }
    return _results;
  };

  updatePackageJson = function(cutCommits, rawPackageJson, commitLogs, newestCommits) {
    var newestCommit, oldCommit, projectName;
    for (projectName in newestCommits) {
      newestCommit = newestCommits[projectName];
      oldCommit = cutCommits[projectName];
      rawPackageJson = rawPackageJson.replace(oldCommit, newestCommit);
    }
    return console.log(rawPackageJson);
  };

  addCommitLog = function(commitLogs) {
    var detail, logs, oneliner, projectName, projectsUpdated;
    detail = '';
    projectsUpdated = [];
    for (projectName in commitLogs) {
      logs = commitLogs[projectName];
      if (logs.length === 0) {
        continue;
      }
      projectsUpdated.push(projectName);
      detail += logs.join('\n');
      detail += '\n';
    }
    oneliner = 'Update ' + projectsUpdated.join(', ');
    return oneliner + '\n\n' + detail;
  };

  getPackageJsonCommits = function(rawPackageJson) {
    var commitRef, depName, depVer, isGit, isOurRepo, isSpecific, ourPrefix, packageJson, projectName, repoURL, usedCommits, _ref, _ref1;
    usedCommits = {};
    packageJson = JSON.parse(rawPackageJson);
    _ref = packageJson.dependencies;
    for (depName in _ref) {
      depVer = _ref[depName];
      isGit = depVer.indexOf('git://') === 0;
      if (!isGit) {
        continue;
      }
      isSpecific = depVer.indexOf('#') !== -1;
      if (!isSpecific) {
        continue;
      }
      _ref1 = depVer.split('#'), repoURL = _ref1[0], commitRef = _ref1[1];
      ourPrefix = "git://" + remoteGitHost + "/" + remoteRepoGroup + "/";
      isOurRepo = repoURL.indexOf(ourPrefix) === 0;
      if (!isOurRepo) {
        continue;
      }
      projectName = repoURL.split('/')[4];
      projectName = projectName.replace('.git', '');
      if (depName !== projectName) {
        throw "unexpected package.json entry: dependency name " + depName + " != project name " + projectName + " in " + depVer + ", why?";
      }
      usedCommits[projectName] = commitRef;
    }
    return usedCommits;
  };

  readRepo = function(commitLogs, newestCommits, cutCommit, projectName, gitPath, numProjects, callback) {
    var repo;
    repo = git.repo(path.join(gitPath, '.git'));
    commitLogs[projectName] = [];
    return repo.logWalk('HEAD', function(err, log) {
      var onRead;
      if (err) {
        throw err;
      }
      onRead = function(err, commit) {
        if (err) {
          throw err;
        }
        if (commit) {
          if (newestCommits[projectName] == null) {
            newestCommits[projectName] = commit.hash;
          }
        }
        if (!commit || commit.hash === cutCommit) {
          if (Object.keys(commitLogs).length === numProjects) {
            callback(commitLogs);
          }
          return;
        }
        logCommit(commitLogs, projectName, commit);
        return repo.treeWalk(commit.tree, function(err, tree) {
          var onEntry;
          if (err) {
            throw err;
          }
          onEntry = function(err, entry) {
            if (!entry) {
              return log.read(onRead);
            }
            return tree.read(onEntry);
          };
          return tree.read(onEntry);
        });
      };
      return log.read(onRead);
    });
  };

  logCommit = function(commitLogs, projectName, commit) {
    var firstLine, message;
    firstLine = function(s) {
      return s.split('\n')[0];
    };
    message = "" + remoteRepoGroup + "/" + projectName + "@" + commit.hash + " " + (firstLine(commit.message));
    return commitLogs[projectName].push(message);
  };

  main();

}).call(this);
