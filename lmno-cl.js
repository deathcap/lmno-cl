// Generated by CoffeeScript 1.6.3
(function() {
  var addCommitLog, fs, getCommonHostGroup, getDepVers, getPackageJsonCommits, git, logCommit, main, mostCommon, path, readRepo, root, updatePackageJson;

  fs = require('fs');

  path = require('path');

  git = require('git-node');

  root = '../voxpopuli';

  main = function() {
    var commitLogs, cutCommit, cutCommits, depVers, file, linkedPaths, mostCommonGroup, mostCommonHost, newestCommits, node_modules, numProjects, p1, p2, p3, packageJson, projectName, rawPackageJson, stats, _i, _j, _len, _len1, _ref, _ref1, _results;
    rawPackageJson = fs.readFileSync(path.join(root, 'package.json'));
    packageJson = JSON.parse(rawPackageJson);
    depVers = getDepVers(packageJson);
    _ref = getCommonHostGroup(depVers), mostCommonHost = _ref[0], mostCommonGroup = _ref[1];
    if (mostCommonHost !== 'github.com') {
      print("warning: unknown git host " + mostCommonHost + ", commit references may be incorrect");
    }
    cutCommits = getPackageJsonCommits(mostCommonHost, mostCommonGroup, depVers);
    node_modules = path.join(root, 'node_modules');
    linkedPaths = [];
    _ref1 = fs.readdirSync(node_modules);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      file = _ref1[_i];
      p1 = path.join(node_modules, file);
      stats = fs.lstatSync(p1);
      if (!stats.isSymbolicLink()) {
        continue;
      }
      p2 = fs.readlinkSync(p1);
      p3 = fs.readlinkSync(p2);
      linkedPaths.push(p3);
    }
    numProjects = linkedPaths.length;
    console.log('numProjects', numProjects);
    console.log('linkedPaths', linkedPaths);
    commitLogs = {};
    newestCommits = {};
    _results = [];
    for (_j = 0, _len1 = linkedPaths.length; _j < _len1; _j++) {
      file = linkedPaths[_j];
      projectName = path.basename(file);
      cutCommit = cutCommits[projectName];
      if (cutCommit == null) {
        throw "node module " + projectName + " linked but not found in package.json!";
      }
      _results.push(readRepo(commitLogs, newestCommits, cutCommit, projectName, file, numProjects, function(commitLogs) {
        var logRepoGroup, msg;
        console.log("=======");
        console.log(commitLogs);
        console.log("=======");
        console.log(newestCommits);
        updatePackageJson(cutCommits, rawPackageJson.toString(), commitLogs, newestCommits);
        logRepoGroup = mostCommonGroup;
        msg = addCommitLog(logRepoGroup, commitLogs);
        return console.log("log=", msg);
      }));
    }
    return _results;
  };

  updatePackageJson = function(cutCommits, rawPackageJson, commitLogs, newestCommits) {
    var newestCommit, oldCommit, projectName;
    for (projectName in newestCommits) {
      newestCommit = newestCommits[projectName];
      oldCommit = cutCommits[projectName];
      rawPackageJson = rawPackageJson.replace(oldCommit, newestCommit);
    }
    return console.log(rawPackageJson);
  };

  addCommitLog = function(logRepoGroup, commitLogs) {
    var commit, detail, firstLine, logs, messageLine, oneliner, projectName, projectsUpdated, _i, _len, _ref;
    detail = '';
    projectsUpdated = [];
    firstLine = function(s) {
      return s.split('\n')[0];
    };
    for (projectName in commitLogs) {
      logs = commitLogs[projectName];
      if (logs.length === 0) {
        continue;
      }
      projectsUpdated.push(projectName);
      for (_i = 0, _len = logs.length; _i < _len; _i++) {
        _ref = logs[_i], projectName = _ref[0], commit = _ref[1];
        messageLine = "" + logRepoGroup + "/" + projectName + "@" + commit.hash + " " + (firstLine(commit.message));
        detail += messageLine + '\n';
      }
    }
    oneliner = 'Update ' + projectsUpdated.join(', ');
    return oneliner + '\n\n' + detail;
  };

  getDepVers = function(packageJson) {
    var depName, depVer, depVers, isGit, isSpecific, _ref;
    depVers = {};
    _ref = packageJson.dependencies;
    for (depName in _ref) {
      depVer = _ref[depName];
      isGit = depVer.indexOf('git://') === 0;
      if (!isGit) {
        continue;
      }
      isSpecific = depVer.indexOf('#') !== -1;
      if (!isSpecific) {
        continue;
      }
      depVers[depName] = depVer;
    }
    return depVers;
  };

  getCommonHostGroup = function(depVers) {
    var depName, depVer, group, host, ignoredBlank, ignoredProtocol, repoGroup, repoGroupFreq, repoHost, repoHostFreq, repoPath, _ref;
    repoHostFreq = {};
    repoGroupFreq = {};
    for (depName in depVers) {
      depVer = depVers[depName];
      _ref = depVer.split('/'), ignoredProtocol = _ref[0], ignoredBlank = _ref[1], repoHost = _ref[2], repoGroup = _ref[3], repoPath = _ref[4];
      if (repoHostFreq[repoHost] == null) {
        repoHostFreq[repoHost] = 0;
      }
      repoHostFreq[repoHost] += 1;
      if (repoGroupFreq[repoGroup] == null) {
        repoGroupFreq[repoGroup] = 0;
      }
      repoGroupFreq[repoGroup] += 1;
    }
    host = mostCommon(repoHostFreq);
    group = mostCommon(repoGroupFreq);
    return [host, group];
  };

  mostCommon = function(obj) {
    var freq, maxFreq, name, ret;
    maxFreq = 0;
    ret = void 0;
    for (name in obj) {
      freq = obj[name];
      if (freq > maxFreq) {
        ret = name;
      }
    }
    return ret;
  };

  getPackageJsonCommits = function(expectedHost, expectedGroup, depVers) {
    var commitRef, depName, depVer, isOurRepo, ourPrefix, projectName, repoURL, usedCommits, _ref;
    usedCommits = {};
    for (depName in depVers) {
      depVer = depVers[depName];
      _ref = depVer.split('#'), repoURL = _ref[0], commitRef = _ref[1];
      ourPrefix = "git://" + expectedHost + "/" + expectedGroup + "/";
      isOurRepo = repoURL.indexOf(ourPrefix) === 0;
      if (!isOurRepo) {
        continue;
      }
      projectName = repoURL.split('/')[4];
      projectName = projectName.replace('.git', '');
      if (depName !== projectName) {
        throw "unexpected package.json entry: dependency name " + depName + " != project name " + projectName + " in " + depVer + ", why?";
      }
      usedCommits[projectName] = commitRef;
    }
    return usedCommits;
  };

  readRepo = function(commitLogs, newestCommits, cutCommit, projectName, gitPath, numProjects, callback) {
    var repo;
    repo = git.repo(path.join(gitPath, '.git'));
    commitLogs[projectName] = [];
    return repo.logWalk('HEAD', function(err, log) {
      var onRead;
      if (err) {
        throw err;
      }
      onRead = function(err, commit) {
        if (err) {
          throw err;
        }
        if (commit) {
          if (newestCommits[projectName] == null) {
            newestCommits[projectName] = commit.hash;
          }
        }
        if (!commit || commit.hash === cutCommit) {
          if (Object.keys(commitLogs).length === numProjects) {
            callback(commitLogs);
          }
          return;
        }
        logCommit(commitLogs, projectName, commit);
        return repo.treeWalk(commit.tree, function(err, tree) {
          var onEntry;
          if (err) {
            throw err;
          }
          onEntry = function(err, entry) {
            if (!entry) {
              return log.read(onRead);
            }
            return tree.read(onEntry);
          };
          return tree.read(onEntry);
        });
      };
      return log.read(onRead);
    });
  };

  logCommit = function(commitLogs, projectName, commit) {
    return commitLogs[projectName].push([projectName, commit]);
  };

  main();

}).call(this);
