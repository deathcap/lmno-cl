// Generated by CoffeeScript 1.6.3
(function() {
  var addCommitLog, dryRun, escapechars, fs, getCommonHostGroup, getDepVers, getPackageJsonCommits, git, logCommit, logVerbose, main, mostCommon, path, readRepo, root, shellescape, tagline, updatePackageJson, util,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  git = require('git-node');

  util = require('util');

  root = '.';

  dryRun = __indexOf.call(process.argv, '-n') >= 0;

  logVerbose = __indexOf.call(process.argv, '-v') >= 0;

  tagline = 'Commit message generated by https://github.com/deathcap/lmno-cl';

  main = function() {
    var commitLogs, cutCommit, cutCommits, depName, depVers, file, fileNum, isLast, linkedPaths, mostCommonGroup, mostCommonHost, newestCommits, node_modules, numProjects, p1, p2, p3, packageJson, projectName, projectName2DepName, rawPackageJson, stats, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
    rawPackageJson = fs.readFileSync(path.join(root, 'package.json'));
    packageJson = JSON.parse(rawPackageJson);
    depVers = getDepVers(packageJson);
    _ref = getCommonHostGroup(depVers), mostCommonHost = _ref[0], mostCommonGroup = _ref[1];
    if (mostCommonHost !== 'github.com') {
      console.log(packageJson);
      console.log("\nNo github.com URL dependencies found!");
    }
    _ref1 = getPackageJsonCommits(mostCommonHost, mostCommonGroup, depVers), cutCommits = _ref1[0], projectName2DepName = _ref1[1];
    node_modules = path.join(root, 'node_modules');
    linkedPaths = [];
    _ref2 = fs.readdirSync(node_modules);
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      file = _ref2[_i];
      p1 = path.join(node_modules, file);
      stats = fs.lstatSync(p1);
      if (!stats.isSymbolicLink()) {
        continue;
      }
      p2 = fs.readlinkSync(p1);
      p3 = fs.readlinkSync(p2);
      linkedPaths.push(p3);
    }
    numProjects = linkedPaths.length;
    commitLogs = {};
    newestCommits = {};
    _results = [];
    for (fileNum = _j = 0, _len1 = linkedPaths.length; _j < _len1; fileNum = ++_j) {
      file = linkedPaths[fileNum];
      projectName = path.basename(file);
      depName = projectName2DepName[projectName];
      if (depName == null) {
        depName = projectName;
      }
      process.stderr.write('found ' + depName + '\n');
      cutCommit = cutCommits[depName];
      if (cutCommit == null) {
        process.stderr.write("# WARNING: node module " + projectName + " linked but not found in package.json! (ignoring)\n");
      }
      isLast = fileNum === linkedPaths.length - 1;
      _results.push(readRepo(commitLogs, newestCommits, cutCommit, projectName, file, isLast, function(commitLogs) {
        var cmd, escaped, logRepoGroup, msg;
        updatePackageJson(cutCommits, projectName2DepName, rawPackageJson.toString(), commitLogs, newestCommits);
        logRepoGroup = mostCommonGroup;
        msg = addCommitLog(logRepoGroup, commitLogs);
        cmd = ['git', 'commit', 'package.json', '-m', msg];
        escaped = shellescape(cmd);
        console.log(escaped);
        if (logVerbose) {
          return process.stderr.write(escaped + '\n');
        }
      }));
    }
    return _results;
  };

  updatePackageJson = function(cutCommits, projectName2DepName, rawPackageJson, commitLogs, newestCommits) {
    var depName, newestCommit, oldCommit, projectName;
    for (projectName in newestCommits) {
      newestCommit = newestCommits[projectName];
      depName = projectName2DepName[projectName];
      if (depName == null) {
        depName = projectName;
      }
      oldCommit = cutCommits[depName];
      rawPackageJson = rawPackageJson.replace(oldCommit, newestCommit);
    }
    if (logVerbose) {
      process.stderr.write(rawPackageJson + '\n');
    }
    if (!dryRun) {
      return fs.writeFileSync('package.json', rawPackageJson);
    }
  };

  addCommitLog = function(logRepoGroup, commitLogs) {
    var commit, detail, firstLine, logs, messageLine, oneliner, projectName, projectsUpdated, _i, _len, _ref;
    detail = '';
    projectsUpdated = [];
    firstLine = function(s) {
      return s.split('\n')[0];
    };
    for (projectName in commitLogs) {
      logs = commitLogs[projectName];
      if (logs.length === 0) {
        continue;
      }
      projectsUpdated.push(projectName);
      for (_i = 0, _len = logs.length; _i < _len; _i++) {
        _ref = logs[_i], projectName = _ref[0], commit = _ref[1];
        messageLine = "" + logRepoGroup + "/" + projectName + "@" + commit.hash + " " + (firstLine(commit.message));
        detail += messageLine + '\n';
      }
    }
    oneliner = 'Update ' + projectsUpdated.join(', ');
    return oneliner + '\n\n' + detail + '\n' + tagline;
  };

  getDepVers = function(packageJson) {
    var depName, depVer, depVers, isGit, isSpecific, _ref;
    depVers = {};
    _ref = packageJson.dependencies;
    for (depName in _ref) {
      depVer = _ref[depName];
      isGit = depVer.indexOf('git://') === 0;
      if (!isGit) {
        continue;
      }
      isSpecific = depVer.indexOf('#') !== -1;
      if (!isSpecific) {
        continue;
      }
      depVers[depName] = depVer;
    }
    return depVers;
  };

  getCommonHostGroup = function(depVers) {
    var depName, depVer, group, host, ignoredBlank, ignoredProtocol, repoGroup, repoGroupFreq, repoHost, repoHostFreq, repoPath, _ref;
    repoHostFreq = {};
    repoGroupFreq = {};
    for (depName in depVers) {
      depVer = depVers[depName];
      _ref = depVer.split('/'), ignoredProtocol = _ref[0], ignoredBlank = _ref[1], repoHost = _ref[2], repoGroup = _ref[3], repoPath = _ref[4];
      if (repoHostFreq[repoHost] == null) {
        repoHostFreq[repoHost] = 0;
      }
      repoHostFreq[repoHost] += 1;
      if (repoGroupFreq[repoGroup] == null) {
        repoGroupFreq[repoGroup] = 0;
      }
      repoGroupFreq[repoGroup] += 1;
    }
    host = mostCommon(repoHostFreq);
    group = mostCommon(repoGroupFreq);
    return [host, group];
  };

  mostCommon = function(obj) {
    var freq, maxFreq, name, ret;
    maxFreq = 0;
    ret = void 0;
    for (name in obj) {
      freq = obj[name];
      if (freq > maxFreq) {
        ret = name;
      }
    }
    return ret;
  };

  getPackageJsonCommits = function(expectedHost, expectedGroup, depVers) {
    var commitRef, depName, depVer, isOurRepo, ourPrefix, projectName, projectName2DepName, repoURL, usedCommits, _ref;
    usedCommits = {};
    projectName2DepName = {};
    for (depName in depVers) {
      depVer = depVers[depName];
      _ref = depVer.split('#'), repoURL = _ref[0], commitRef = _ref[1];
      ourPrefix = "git://" + expectedHost + "/" + expectedGroup + "/";
      isOurRepo = repoURL.indexOf(ourPrefix) === 0;
      if (!isOurRepo) {
        continue;
      }
      projectName = repoURL.split('/')[4];
      projectName = projectName.replace('.git', '');
      if (depName !== projectName) {
        process.stderr.write("# WARNING: unexpected package.json entry: dependency name " + depName + " != project name " + projectName + " in " + depVer + ", why? (using dependency name " + depName + "n");
        projectName2DepName[projectName] = depName;
      }
      usedCommits[depName] = commitRef;
    }
    return [usedCommits, projectName2DepName];
  };

  readRepo = function(commitLogs, newestCommits, cutCommit, projectName, gitPath, isLast, callback) {
    var repo;
    repo = git.repo(path.join(gitPath, '.git'));
    commitLogs[projectName] = [];
    return repo.logWalk('HEAD', function(err, log) {
      var onRead;
      if (err) {
        throw err;
      }
      onRead = function(err, commit) {
        if (err) {
          throw err;
        }
        if (commit) {
          if (newestCommits[projectName] == null) {
            newestCommits[projectName] = commit.hash;
          }
        }
        if (!commit || commit.hash === cutCommit) {
          if (isLast) {
            callback(commitLogs);
          }
          return;
        }
        logCommit(commitLogs, projectName, commit);
        return repo.treeWalk(commit.tree, function(err, tree) {
          var onEntry;
          if (err) {
            throw err;
          }
          onEntry = function(err, entry) {
            if (!entry) {
              return log.read(onRead);
            }
            return tree.read(onEntry);
          };
          return tree.read(onEntry);
        });
      };
      return log.read(onRead);
    });
  };

  logCommit = function(commitLogs, projectName, commit) {
    return commitLogs[projectName].push([projectName, commit]);
  };

  escapechars = [' ', ';', '&', '#', '>', '<', '{', '}', '$', '(', ')', '[', ']', '"', '|', '*', '!', '^', '?', '+', '~', '`'];

  shellescape = function(a) {
    var ret;
    ret = [];
    a.forEach(function(s) {
      var i, needsQuoting, _i, _len;
      for (_i = 0, _len = escapechars.length; _i < _len; _i++) {
        i = escapechars[_i];
        if (s.indexOf(escapechars[i]) > -1) {
          s = util.inspect(s);
          break;
        }
      }
      s = s.replace(/'/g, '\'"\'"\'');
      needsQuoting = s.indexOf(' ') !== -1 || s.indexOf('\n') !== -1;
      if (needsQuoting) {
        s = "'" + s + "'";
      }
      return ret.push(s);
    });
    return ret.join(' ');
  };

  main();

}).call(this);
